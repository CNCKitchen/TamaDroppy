#include <SPI.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_ADXL375.h>
#include <Arduino.h>
#include <U8g2lib.h>
#include <Adafruit_NeoPixel.h>
#include <OneButton.h>

#define ADXL375_CS 6
#define NEOPIXEL_PIN 1
#define BUTTON_PIN 0
#define SD_CS 7
#define SD_SCK 8

// IMAGES
static unsigned char splashScreen[] U8X8_PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x40, 0x60, 0x00, 0x00, 0x00,
  0x00, 0xf8, 0x4f, 0xc0, 0x60, 0x60, 0x00, 0x00, 0x00, 0xf8, 0xe1, 0xc0,
  0x60, 0xe0, 0x00, 0x00, 0x00, 0x80, 0xe1, 0xc8, 0x71, 0xa0, 0x06, 0x00,
  0x00, 0x80, 0xb1, 0xc7, 0xf1, 0xb0, 0x07, 0x00, 0x00, 0x80, 0xb1, 0x43,
  0xf3, 0xf0, 0x01, 0x00, 0x00, 0x80, 0xf1, 0x43, 0xb6, 0xf8, 0x01, 0x00,
  0x00, 0x80, 0x71, 0x62, 0x9c, 0x1c, 0x03, 0x00, 0x00, 0x80, 0x19, 0x66,
  0x9c, 0x19, 0x03, 0x00, 0x00, 0x80, 0x19, 0x26, 0x98, 0x09, 0x06, 0x00,
  0x00, 0x80, 0x19, 0x2c, 0x98, 0x09, 0x06, 0x00, 0x00, 0x80, 0x00, 0x2c,
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x60, 0x00,
  0x10, 0x80, 0x00, 0x00, 0x00, 0xf8, 0xf1, 0x03, 0xf8, 0x00, 0x21, 0x00,
  0x00, 0xfc, 0x63, 0x46, 0x3c, 0x01, 0x33, 0x00, 0x00, 0x1a, 0x66, 0xec,
  0x31, 0x02, 0x3e, 0x00, 0x00, 0x18, 0x6c, 0x36, 0x32, 0x0a, 0x3c, 0x00,
  0x00, 0x18, 0xec, 0x31, 0xf4, 0x7d, 0x1c, 0x00, 0x00, 0x18, 0xec, 0x30,
  0x74, 0x9e, 0x18, 0x00, 0x00, 0x18, 0xec, 0x31, 0x3c, 0x18, 0x0d, 0x00,
  0x00, 0x18, 0x6e, 0x67, 0x36, 0x18, 0x0d, 0x00, 0x00, 0x98, 0x67, 0xce,
  0x33, 0xf8, 0x04, 0x00, 0x00, 0xf8, 0x63, 0x00, 0x10, 0x38, 0x04, 0x00,
  0x00, 0xfc, 0x20, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static unsigned char crying_bits[] = {
  0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x00, 0xf0, 0x08, 0x00, 0x00, 0x20, 0x1e, 0x00,
  0x00, 0x08, 0x07, 0x00, 0x00, 0xc0, 0x21, 0x00, 0x00, 0x04, 0x04, 0x00,
  0x00, 0x40, 0x40, 0x00, 0x00, 0x02, 0x08, 0x07, 0xc0, 0x21, 0x80, 0x00,
  0x00, 0x02, 0x90, 0x0f, 0xe0, 0x13, 0x80, 0x00, 0x00, 0x02, 0x48, 0x18,
  0x30, 0x24, 0x80, 0x00, 0x00, 0x04, 0x04, 0x10, 0x10, 0x40, 0x40, 0x00,
  0x00, 0x18, 0x73, 0x00, 0x00, 0x9c, 0x31, 0x00, 0x00, 0xe0, 0x4e, 0x00,
  0x00, 0xe4, 0x0e, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x84, 0x00, 0x00,
  0x00, 0x00, 0x41, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x80, 0x20, 0xc0,
  0x07, 0x08, 0x02, 0x00, 0x00, 0x80, 0x20, 0x30, 0x18, 0x08, 0x02, 0x00,
  0x00, 0x80, 0x10, 0x08, 0x20, 0x10, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x04,
  0x40, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04, 0x40, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0xa0, 0x01, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06,
  0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf8, 0x3f, 0x04, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x0c, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x13,
  0x90, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x11, 0x10, 0x65, 0x00, 0x00,
  0x00, 0x00, 0xfe, 0x1f, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10,
  0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xf0, 0xff, 0x01, 0x00
};

static unsigned char cracked_bits[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
  0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x09, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x80, 0xe0, 0x09, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x90, 0xe0,
  0x1d, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xd0, 0xf1, 0x1f, 0x3e, 0x00, 0x00,
  0x00, 0x00, 0xd0, 0xf1, 0x3f, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xe8, 0xfb,
  0x7b, 0x2f, 0x00, 0x00, 0x00, 0x00, 0xe8, 0xfb, 0xf3, 0x2f, 0x00, 0x00,
  0x00, 0x00, 0xe8, 0xff, 0xf1, 0x2f, 0x00, 0x00, 0x00, 0x00, 0xc4, 0xff,
  0xe1, 0x47, 0x00, 0x00, 0x00, 0x00, 0xc4, 0xfb, 0xc0, 0x47, 0x00, 0x00,
  0x00, 0x00, 0xc4, 0xfb, 0xc0, 0x43, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x71,
  0x80, 0x43, 0x00, 0x00, 0x00, 0x00, 0x82, 0x71, 0x80, 0x81, 0x00, 0x00,
  0x00, 0x00, 0x82, 0x20, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x02, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03,
  0x80, 0x01, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x13, 0x01, 0x00,
  0x00, 0x00, 0xe1, 0x00, 0x00, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0xc0, 0x01, 0x01, 0x00,
  0x00, 0x00, 0x81, 0x0f, 0xe0, 0x03, 0x01, 0x00, 0x00, 0x00, 0xc1, 0x1c,
  0x30, 0x07, 0x01, 0x00, 0x00, 0x00, 0xc1, 0x1c, 0x30, 0x07, 0x01, 0x00,
  0x00, 0x00, 0xc1, 0x1f, 0xf0, 0x07, 0x01, 0x00, 0x00, 0x00, 0x82, 0x0f,
  0xe0, 0x83, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0xc0, 0x81, 0x00, 0x00,
  0x00, 0x00, 0x04, 0x80, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x60,
  0x0c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x10, 0x20, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x08, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0xa0, 0x01, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06,
  0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf8, 0x3f, 0x04, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x0c, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x13,
  0x90, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x11, 0x10, 0x65, 0x00, 0x00,
  0x00, 0x00, 0xfe, 0x1f, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10,
  0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xf0, 0xff, 0x01, 0x00
};

static unsigned char dead_bits[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
  0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x03, 0xb0, 0x00,
  0x00, 0x00, 0x38, 0x00, 0x00, 0x04, 0xa8, 0x00, 0x00, 0x00, 0x06, 0x00,
  0x80, 0x1a, 0xa8, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc0, 0xf1, 0xac, 0x00,
  0x00, 0x80, 0x00, 0x40, 0x84, 0x00, 0x67, 0x00, 0x00, 0x40, 0x00, 0x80,
  0x02, 0x23, 0x54, 0x00, 0x00, 0x20, 0x00, 0x80, 0x81, 0x44, 0x54, 0x00,
  0x00, 0x10, 0x00, 0x80, 0x41, 0x40, 0x52, 0x00, 0x00, 0x88, 0x07, 0x80,
  0x00, 0x80, 0x53, 0x00, 0x00, 0x84, 0x00, 0x80, 0x00, 0x80, 0x7e, 0x00,
  0x00, 0x44, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x22, 0x00, 0xe0,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0xe0, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x02, 0x00, 0x10, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x08,
  0x02, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x0f, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x02, 0x00, 0x1d, 0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x80, 0x18,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x04, 0x60, 0x38, 0x00, 0x80, 0x7e, 0x00,
  0x00, 0x08, 0x00, 0x5c, 0x00, 0x80, 0x53, 0x00, 0x00, 0x10, 0x00, 0x2c,
  0x00, 0x40, 0x52, 0x00, 0x00, 0x20, 0x00, 0x0c, 0x20, 0x40, 0x54, 0x00,
  0x00, 0x40, 0x00, 0x0c, 0x20, 0x20, 0x54, 0x00, 0x00, 0x80, 0x00, 0x0e,
  0x10, 0x10, 0x67, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x90, 0xf8, 0xa8, 0x00,
  0x00, 0x00, 0x02, 0x1e, 0x38, 0x04, 0xa8, 0x00, 0x00, 0x00, 0x04, 0x1e,
  0x20, 0x02, 0xa8, 0x00, 0x00, 0xc0, 0x1f, 0x1e, 0x10, 0x01, 0xb0, 0x00,
  0x00, 0x38, 0xfc, 0x7f, 0xe0, 0x01, 0xe0, 0x00, 0x00, 0x8c, 0xff, 0xff,
  0x3f, 0x06, 0x00, 0x00, 0xf8, 0x03, 0xe0, 0xff, 0x07, 0x08, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0xc0, 0x01, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00
};

static unsigned char laughing_bits[] = {
  0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x07, 0xc0, 0x11, 0x00, 0x00, 0x00, 0x00, 0x88, 0x08,
  0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xc0, 0x41, 0x00, 0x00,
  0x00, 0x00, 0x84, 0x0f, 0xe0, 0x43, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x19,
  0x30, 0x47, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x19, 0x30, 0x87, 0x00, 0x00,
  0x00, 0x00, 0xc2, 0x1f, 0xf0, 0x87, 0x00, 0x00, 0x00, 0x00, 0x82, 0x0f,
  0xe0, 0x83, 0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0xc0, 0x81, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x02,
  0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0xfe, 0xff, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x06, 0xc0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04,
  0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x3c, 0x78, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x01, 0x08, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x08,
  0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x10, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x04, 0xe0, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0xa0, 0x01, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06,
  0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf8, 0x3f, 0x04, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x0c, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x13,
  0x90, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x11, 0x10, 0x65, 0x00, 0x00,
  0x00, 0x00, 0xfe, 0x1f, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10,
  0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xf0, 0xff, 0x01, 0x00
};

// NeoPixel
Adafruit_NeoPixel pixels(2, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);

//OLED
U8G2_SSD1306_64X48_ER_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE);  // EastRising 0.66" OLED breakout board, Uno: A4=SDA, A5=SCL, 5V powered

//Button
OneButton btn = OneButton(
  BUTTON_PIN,  // Input pin for the button
  true,        // Button is active LOW
  true         // Enable internal pull-up resistor
);

//Accelerometer
Adafruit_ADXL375 accel = Adafruit_ADXL375(12345);  //I2C

//Data acquisition & General Settings
const int samples = 1500;
const int samplesBeforeImpact = 250;
const float accelerationThreshold = 12;         //g
const int threasholdSamples = 3;               // x samples in a row need to be over the threashold
const unsigned int measuringDelay = 500;       //500 us = 2000Hz
const unsigned int displaySwitchDelay = 6000;  //5000 ms = 5 s

// Neopixel
const unsigned long LEDupdate = 50;  //update every 200ms
const int minBrightness = 10;        //%
const int maxBrightness = 100;       //%
const int brightnessStep = 5;        //%p per update
const float jetGreen = 20;           //EIG value for green ==> JET COLOR MAP
const float jetYellow = 100;         //EIG value for yellow
const float jetRed = 200;            //EIG value for red (everything above is purple)

//Arrays
unsigned long timeStamp[samples];
float accXarr[samples];
float accYarr[samples];
float accZarr[samples];
float accResArr[samples];
float aIntegrated[samples - 1];
float theasholdArr[threasholdSamples] = { 0 };
int pixelColor[3] = { 0 };  //Initial Pixel Color

//General Variables
int counter = 0;
int tempCounter = 0;
int maxSample = -1;  //Counter at the threshold acceleration
float currentG = 0;
float currentEIG = 0;
float currentMinJerk = 0;
float currentMaxJerk = 0;
float overallMaxEIC = 0;
float overallMinJerk = 0;
float overallMaxJerk = 0;
bool overload = false;
int currentBrightness = 100;
int fadeDirection = -1;
int displayPage = 0;
unsigned long lastTime;         //Mills timestampForLED ipdate
unsigned long lastTimeDisplay;  //Mills timestampForLED ipdate
unsigned long lastTimestamp;    //Micros Timestamp for acc update
int fileNameNumber = 0;
String fileName;

//## Button
static void handleClick() {  //One click action
  Serial.println("Clicked!");
}

static void handleLongClick() {  //Long click action
  Serial.println("RESET!");
  overallMaxEIC = 0;
  setJetMap(0.);
  updateDisplay(0., 0., false);
  cleanArrays();
  fileNameNumber = getNewFileName();
  fileName = String(fileNameNumber) + ".txt";
}

int mod(int a, int b) {  //Calculate modulo
  int r = a % b;
  return r < 0 ? r + b : r;
}

void setColor(int r, int g, int b) {  //Set LED color
  pixelColor[0] = r;
  pixelColor[1] = g;
  pixelColor[2] = b;
}

void setJetMap(float thisEIC) {  //Interpolation function for Jet Color Map
  // Make sure the input number is within the valid range
  if (thisEIC < 0) {
    thisEIC = 0;
  }

  // Compute the RGB values based on the input number
  if (thisEIC < jetGreen) {
    pixelColor[0] = 0;
    pixelColor[1] = thisEIC / jetGreen * 255.;
    pixelColor[2] = 255 - (thisEIC / jetGreen * 255);
  } else if (thisEIC < jetYellow) {
    thisEIC -= jetGreen;
    pixelColor[0] = thisEIC / (jetYellow - jetGreen) * 255.;
    pixelColor[1] = 255;
    pixelColor[2] = 0;
  } else if (thisEIC <= jetRed) {
    thisEIC -= jetYellow;
    pixelColor[0] = 255;
    pixelColor[1] = 255 - (thisEIC / (jetRed - jetYellow) * 255);
    pixelColor[2] = 0;
  } else {
    pixelColor[0] = 255;
    pixelColor[1] = 0;
    pixelColor[2] = 255;
  }
}

//Makes the lights slowly fade from bright to dim
void updateFade() {
  if (millis() >= lastTime + LEDupdate) {
    currentBrightness += brightnessStep * fadeDirection;
    if (currentBrightness > maxBrightness) {
      fadeDirection = -1;
      currentBrightness += brightnessStep * fadeDirection;
    } else if (currentBrightness < minBrightness) {
      fadeDirection = 1;
      currentBrightness += brightnessStep * fadeDirection;
    }
    //Serial.println(currentBrightness);
    pixels.clear();
    int red = pixelColor[0] * (currentBrightness / 100.);
    int green = pixelColor[1] * (currentBrightness / 100.);
    int blue = pixelColor[2] * (currentBrightness / 100.);
    //Serial.println(blue);

    pixels.setPixelColor(0, pixels.Color(pixelColor[0] * (currentBrightness / 100.), pixelColor[1] * (currentBrightness / 100.), pixelColor[2] * (currentBrightness / 100.)));
    pixels.setPixelColor(1, pixels.Color(pixelColor[0] * (currentBrightness / 100.), pixelColor[1] * (currentBrightness / 100.), pixelColor[2] * (currentBrightness / 100.)));
    pixels.show();
    lastTime = millis();
  }
}

//get the shifted index of the ring memory
int getIndex(int startIndex, int currentIndex) {
  return mod(currentIndex + startIndex - samplesBeforeImpact, samples);
}

//clean the whole samples array
void cleanArrays() {
  for (int i = 0; i < samples; i++) {
    timeStamp[i] = 0;
    accXarr[i] = 0;
    accYarr[i] = 0;
    accZarr[i] = 0;
    accResArr[i] = 0;
    if (i < (samples - 1)) {
      aIntegrated[i] = 0;
    }
  }
}

//Calculate the egg injury criterion (similar to Head Injury Criterion: https://en.m.wikipedia.org/wiki/Head_injury_criterion)
float calculateEIC(unsigned long duration, int startIndex) {
  float maxEIC = 0;

  //integrate all values
  for (int j = 0; j < samples - 1; j++) {
    int i = getIndex(startIndex, j);        //Get shifted index from ring memory
    int ip1 = getIndex(startIndex, j + 1);  //Get shifted index from ring memory
    unsigned long int dTimestamp = (timeStamp[ip1] - timeStamp[i]);

    //micros() overflow handling (should also do it for the rest of the function...)
    if (dTimestamp < 512 || dTimestamp > 5000) {
      Serial.println("WARNING: Overflow!");
      Serial.println(dTimestamp);
      dTimestamp = 977;  //1024 Hz      
    }

    aIntegrated[i] = (accResArr[i] + accResArr[ip1]) / 2 * (dTimestamp / 1000000.);
  }

  for (int i = 0; i < samples - 1; i++) {
    float currentaIntegratedSum = 0;
    int j = i;
    while ((timeStamp[getIndex(startIndex, j)] - timeStamp[getIndex(startIndex, i)]) <= (duration * 1000)) {
      currentaIntegratedSum += aIntegrated[getIndex(startIndex, j)];
      j++;
      if (j >= (samples)) {
        break;
      }
    }

    j--;
    float currentEIC = (timeStamp[getIndex(startIndex, j)] - timeStamp[getIndex(startIndex, i)]) / 1000000.0 * pow((1 / ((timeStamp[getIndex(startIndex, j)] - timeStamp[getIndex(startIndex, i)]) / 1000000.0) * currentaIntegratedSum), 2.5);

    if (currentEIC > maxEIC) {
      maxEIC = currentEIC;
    }
  }

  return maxEIC;
}

//Calculate the egg injury criterion (similar to Head Injury Criterion: https://en.m.wikipedia.org/wiki/Head_injury_criterion)
float calculateJerk(int startIndex, bool minMax) {
  float maxJerk = 0;

  for (int j = 0; j < samples - 1; j++) {
    int i = getIndex(startIndex, j);        //Get shifted index from ring memory
    int ip1 = getIndex(startIndex, j + 1);  //Get shifted index from ring memory
    unsigned long int dTimestamp = (timeStamp[ip1] - timeStamp[i]);
    
    float jerk = (accResArr[ip1] - accResArr[i]) / (dTimestamp/1000.);

    if(minMax) {
      if(jerk > maxJerk) {
        maxJerk = jerk;
      }
    } else {
      if(jerk < maxJerk) {
        maxJerk = jerk;
      }
    }
  }
  return maxJerk;
}


void tickDisplay() {
  if (millis() >= lastTimeDisplay + displaySwitchDelay) {
    if (displayPage == 0) {  // Show Image
      displayPage = 1;
      u8g2.firstPage();
      if (overallMaxEIC < jetGreen) {
        u8g2.drawXBMP(0, 0, 64, 48, laughing_bits);
      } else if (overallMaxEIC < jetYellow) {
        u8g2.drawXBMP(0, 0, 64, 48, crying_bits);
      } else if (overallMaxEIC <= jetRed) {
        u8g2.drawXBMP(0, 0, 64, 48, cracked_bits);
      } else {
        u8g2.drawXBMP(0, 0, 64, 48, dead_bits);
      }
      u8g2.sendBuffer();  // transfer internal memory to the display
    } else {
      displayPage = 0;
      showStats();
    }
    lastTimeDisplay = millis();
  }
}

void showStats() {
  //Update Screen
  u8g2.clearBuffer();              // clear the internal memory
  u8g2.setFont(u8g2_font_5x7_tf);  // choose a suitable font
  u8g2.drawStr(0, 10, "acc");    // write something to the internal memory
  if (overload) {
    u8g2.drawStr(20, 10, "OVERLOAD");  // write something to the internal memory
  } else {
    u8g2.setCursor(30, 10);
    u8g2.print(currentG,0);
  }
  u8g2.setCursor(30, 20);
  u8g2.print(currentEIG,1);
  u8g2.drawStr(0, 20, "EIC32");  // write something to the internal memory
  //########
  u8g2.drawStr(0, 29, "Jrk");  // write something to the internal memory
  u8g2.setCursor(22, 29);
  u8g2.print(currentMinJerk,0);
  u8g2.setCursor(46, 29);
  u8g2.print(currentMaxJerk,0);
  //########
  u8g2.drawStr(0, 38, "mxEIC32");  // write something to the internal memory
  u8g2.setCursor(38, 38);
  u8g2.print(overallMaxEIC,1);
  u8g2.sendBuffer();  // transfer internal memory to the display
  //########
  u8g2.drawStr(0, 47, "mxJk");  // write something to the internal memory
  u8g2.setCursor(22, 47);
  u8g2.print(overallMinJerk,0);
  u8g2.setCursor(46, 47);
  u8g2.print(overallMaxJerk,0);

  u8g2.sendBuffer();  // transfer internal memory to the display
}


void updateDisplay(float maxG, float maxEIG, bool currentOverload) {
  currentG = maxG;
  currentEIG = maxEIG;
  overload = currentOverload;
}

void printResults(int startCounter) {
  unsigned long beforems = millis();
  bool overload = false;
  unsigned long firstTimestamp = timeStamp[getIndex(startCounter, 0)];
  float maxG = 0.0;

  float EIC = calculateEIC(32, startCounter);
  if (EIC > overallMaxEIC) {
    overallMaxEIC = EIC;
  }

  // Claculate Jerk
  currentMinJerk = calculateJerk(startCounter,false);
  currentMaxJerk = calculateJerk(startCounter,true);
  Serial.print("Jerk: ");
  Serial.print(currentMinJerk);
  Serial.print(" / ");
  Serial.println(currentMaxJerk);

  if(currentMinJerk < overallMinJerk) {
    overallMinJerk = currentMinJerk;
  }
  if(currentMaxJerk > overallMaxJerk) {
    overallMaxJerk = currentMaxJerk;
  }

  showStats();

  Serial.println("Writing event to SD!");
  File dataFile = SD.open(fileName, FILE_WRITE);

  dataFile.println(" ");
  dataFile.println(" ");
  dataFile.println(" ");
  dataFile.println("Event Start: " + String(firstTimestamp));

  //Serial.print("startCounter: ");
  //Serial.println(startCounter);

  Serial.print("Open File: ");
  Serial.print(((millis() - beforems) / 1000.));
  Serial.println(" s");

  for (tempCounter = 0; tempCounter < samples - 1; tempCounter++) {
    int dataIndex = getIndex(startCounter, tempCounter);  //mod(tempCounter + startCounter - samplesBeforeImpact, samples);
    //// Calculate resulting acc
    //float resultingG = sqrt((accXarr[dataIndex] * accXarr[dataIndex]) + (accYarr[dataIndex] * accYarr[dataIndex]) + (accZarr[dataIndex] * accZarr[dataIndex]));
    //dataFile.println(String(timeStamp[dataIndex]) + "," + String(accXarr[dataIndex]) + "," + String(accYarr[dataIndex]) + "," + String(accZarr[dataIndex]) + "," + String(accResArr[dataIndex]));
    dataFile.print((timeStamp[dataIndex]) - firstTimestamp);
    dataFile.print(",");
    dataFile.print(accXarr[dataIndex], 1);
    dataFile.print(",");
    dataFile.print(accYarr[dataIndex], 1);
    dataFile.print(",");
    dataFile.println(accZarr[dataIndex], 1);
    //dataFile.print(",");
    //dataFile.println(accResArr[dataIndex], 1);
    if (accResArr[dataIndex] > maxG) {
      maxG = accResArr[dataIndex];
    }
    if (abs(accXarr[dataIndex]) > 200. || abs(accYarr[dataIndex]) > 200. || abs(accZarr[dataIndex]) > 200.) {
      overload = true;
    }
  }
  dataFile.print("EIC = ");
  dataFile.println(EIC);
  dataFile.print("max g = ");
  dataFile.println(maxG);
  dataFile.print("jerk = ");
  dataFile.print(currentMinJerk);
  dataFile.print(" / ");
  dataFile.println(currentMaxJerk);

  //dataFile.println("END of Event");
  dataFile.close();

  Serial.print("Export finished: ");
  Serial.print(((millis() - beforems) / 1000.));
  Serial.println(" s");

  //Serial.print("Max acceleration: ");
  //Serial.print(maxG);
  //Serial.println(" g");

  setJetMap(overallMaxEIC);
  updateDisplay(maxG, EIC, overload);

  //Serial.print("EIC calculated: ");
  //Serial.print(((millis() - beforems) / 1000.));
  //Serial.println(" s");

  Serial.println("EIC = " + String(EIC));
  Serial.println("Event recorded!");
}

int getNewFileName() {
  File root = SD.open("/");
  int maxNumber = -1;
  if (root) {
    File entry;
    while ((entry = root.openNextFile())) {
      if (!entry.isDirectory()) {
        String filename = entry.name();
        int dotIndex = filename.lastIndexOf('.');
        if (dotIndex > 0) {
          String numberStr = filename.substring(0, dotIndex);
          int number = numberStr.toInt();
          if (number > maxNumber) {
            maxNumber = number;
          }
        }
      }
      entry.close();
    }
    root.close();
    Serial.print("Max number: ");
    Serial.println(maxNumber);
  }
  return maxNumber + 1;
}

void setup() {
  cleanArrays();

  delay(500);
  // Open serial communications and wait for port to open:
  pinMode(SD_SCK, OUTPUT);
  digitalWrite(SD_SCK, LOW);

  Serial.begin(57600);
  delay(1000);
  //while (!Serial) {
  // wait for serial port to connect. Needed for native USB port only
  //}

  Serial.print("Initializing SD card...");

  // see if the card is present and can be initialized:
  if (!SD.begin(SD_CS)) {
    Serial.println("Card failed, or not present");
    // don't do anything more:
    while (1)
      ;
  }
  Serial.println("card initialized.");
  digitalWrite(SD_SCK, HIGH);

  //get a new file number
  fileNameNumber = getNewFileName();
  fileName = String(fileNameNumber) + ".txt";
  Serial.println(fileName);

  /////BUTTON
  // Single Click event attachment
  btn.attachClick(handleClick);

  btn.attachLongPressStop(handleLongClick);

  btn.setDebounceTicks(100);
  btn.setPressTicks(3000);

  //Charging current
  //pinMode P0_13, OUTPUT);
  //digitalWrite P0_13, LOW); //100 mA

  lastTimestamp = micros();
  ////Write General Data To File
  //File dataFile = SD.open(fileName, FILE_WRITE);
  //dataFile.println("New measuring series");
  //dataFile.print("Sampling Frequency: ");
  //dataFile.print(1000000/measuringDelay);
  //dataFile.close();
  //dataFile.println("Hz");
  ///////////

  //analogReadResolution(12);

  /* Initialise the sensor */
  if (!accel.begin()) {
    /* There was a problem detecting the ADXL375 ... check your connections */
    Serial.println("Ooops, no ADXL375 detected ... Check your wiring!");
    while (1)
      ;
  }

  // Range is fixed at +-200g

  /* Display some basic information on this sensor */
  accel.printSensorDetails();
  accel.setDataRate(ADXL343_DATARATE_3200_HZ);
  Serial.println("");

  ///OLED
  u8g2.begin();

  //u8g2.clearBuffer(); // clear the internal memory
  u8g2.firstPage();
  //u8g2.setFont(u8g2_font_7x14_tf); // choose a suitable font
  //u8g2.drawStr(15, 15, "TAMA"); // write something to the internal memory
  //u8g2.drawStr(10, 35, "DROPPY"); // write something to the internal memory
  u8g2.drawXBMP(0, 0, 64, 48, splashScreen);
  u8g2.sendBuffer();  // transfer internal memory to the display

  //NeoPixel
  lastTime = millis();
  pixels.begin();
  pixelColor[0] = 0;    //RED
  pixelColor[1] = 0;    //GREEN
  pixelColor[2] = 255;  //BLUE
}

void loop() {
  //Check frequency
  //Serial.println("loop started");
  if (micros() >= lastTimestamp + measuringDelay) {
    sensors_event_t event;
    accel.getEvent(&event);
    lastTimestamp = micros();
    timeStamp[counter] = lastTimestamp;
    accXarr[counter] = event.acceleration.x / 9.81;
    accYarr[counter] = event.acceleration.y / 9.81;
    accZarr[counter] = event.acceleration.z / 9.81;
    accResArr[counter] = sqrt((accXarr[counter] * accXarr[counter]) + (accYarr[counter] * accYarr[counter]) + (accZarr[counter] * accZarr[counter]));
    //Serial.println("recording acc");

    // Check if impact event occured
    if (maxSample == -1) {
      //Rearrange Threashold Array
      for (int i = 1; i < threasholdSamples; i++) {
        theasholdArr[i - 1] = theasholdArr[i];
      }
      theasholdArr[threasholdSamples - 1] = accResArr[counter];
      //Check if all are above the threashold
      bool aboveThreashold = true;
      for (int i = 0; i < threasholdSamples; i++) {
        if (theasholdArr[i] < accelerationThreshold) {
          aboveThreashold = false;
        }
      }
      if (aboveThreashold) {  //Signal recording
        maxSample = counter;
        setColor(128, 128, 128);
        pixels.clear();
        pixels.setPixelColor(0, pixels.Color(pixelColor[0], pixelColor[1], pixelColor[2]));
        pixels.setPixelColor(1, pixels.Color(pixelColor[0], pixelColor[1], pixelColor[2]));
        pixels.show();
        for (int i = 0; i < threasholdSamples; i++) {
          Serial.println(theasholdArr[i]);
        }
        Serial.println(" ");
      }
    }

    //all samples gathered, writing results
    if (maxSample != -1 && counter == (maxSample + samples - samplesBeforeImpact) % samples) {
      setColor(0, 0, 0);
      pixels.clear();
      pixels.setPixelColor(0, pixels.Color(pixelColor[0], pixelColor[1], pixelColor[2]));
      pixels.setPixelColor(1, pixels.Color(pixelColor[0], pixelColor[1], pixelColor[2]));
      pixels.show();
      printResults(maxSample + 1);
      counter = 0;
      maxSample = -1;
      cleanArrays();
      //delay(1000);
    }
    counter++;
    if (counter >= samples) {
      counter = 0;
    }
  }

  if (maxSample == -1) { //Don't do anything while recoring data!
    btn.tick();     //Button Press
    updateFade();   //Fade Routine
    tickDisplay();  //Screen Update
  }
}